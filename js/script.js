
'use strict';

//Функция принимает первым параметром тип данных , а вторым собирает в массив,данные переданные пользователем 
//функция filter проверит,на соответсвие данных - типу. и вернет массив,значений которые соответствуют типу.
const filterByType = (type, ...values) => values.filter(value => typeof value === type),


	//Находим блоки которые выводят сообщениея и скрываем их(display:none)
	hideAllResponseBlocks = () => {
		const responseBlocksArray = Array.from(document.querySelectorAll('div.dialog__response-block'));
		responseBlocksArray.forEach(block => block.style.display = 'none');
	},


//функция showResponseBlock принимает селектор,соддержания для селектора ,и состояние
	showResponseBlock = (blockSelector, msgText, spanSelector) => {

		//Скрываем Все блоки(если какойто был до этого открыт-он скроется)
		hideAllResponseBlocks();

		//Выбираем селектор(переданный аргументами) и показываем его пользователю
		document.querySelector(blockSelector).style.display = 'block';

		//Если состояние передали то выводим в блок сообщение(оно будет или error или ok)
		if (spanSelector) {
			document.querySelector(spanSelector).textContent = msgText;
		}
	},
	//Это сообщение выйдет если стработает блок catch;
	showError = msgText => showResponseBlock('.dialog__response-block_error', msgText, '#error'),


	//showResults вызывает showResponseBlock в параметрах передаем нужный селектор ,сообщение,и состояние сообщения
	showResults = msgText => showResponseBlock('.dialog__response-block_ok', msgText, '#ok'),
	//Это сообщение выйдет если пользователь не ввел никаких данных
	showNoResults = () => showResponseBlock('.dialog__response-block_no-results'),



	//Фунция которая вызвана при нажатие по кнопке,если пользователь ввел данные
	//Принимает Тип и данные которые ввел пользователь
	tryFilterByType = (type, values) => {

		//Если в параметрах values передать неправильный тип данных,то ввыкинет ошибку.
		try {

			//Вызываем функцию filterByType , передаем в качестве аргумента тип данных и данные введeные пользователем
			const valuesArray = eval(`filterByType('${type}', ${values})`).join(", ");//Функция возвращает массив с элементами которые соответствуют типу.
			//Eval,представит values как передаваемые аргументы.


			//Проверяем размер строки отфильрованных значений
			const alertMsg = (valuesArray.length) ?

				//Если она не пустая то мы выводим значения которые совпали по типу.
				`Данные с типом ${type}: ${valuesArray}` :
				//Если пустая то выводим сообщение что данные введеные пользователем не соответствуют типу
				`Отсутствуют данные типа ${type}`;

				//Фунция 	showResults показывает пользоателю результат
			showResults(alertMsg);

			//Блок catch поймает ошибку и обработает ее
		} catch (e) {
			showError(`Ошибка: ${e}`);
		}
	};


//Находим кнопку В разметке
const filterButton = document.querySelector('#filter-btn');

//Обработчик события по клику.
filterButton.addEventListener('click', e => {

	//Находим инпуты  (Тип которые выбрал пользователь) И данные которые он ввел для проверки
	const typeInput = document.querySelector('#type');
	const dataInput = document.querySelector('#data');

	//Если пользователь оставил поле пустым
	if (dataInput.value === '') {
		// Выдаем ему HTML warning что поле не должно быть пустым
		dataInput.setCustomValidity('Поле не должно быть пустым!');
		showNoResults();
	} else {

		//Если же поле ввода не пустое,то отменяем стандартное поведение,и начинаем проверку
		dataInput.setCustomValidity('');
		e.preventDefault();

		//Очищаем информацию которую ввел пользователь (и тип данных) от пробелов,
		//Вызываем функцю tryFilterByType
		tryFilterByType(typeInput.value.trim(), dataInput.value.trim());
	}
});







/*
1.Выбираем тип данных которые мы хотим отфильтровать. строка 73(находим его в разметке)
2.Вводим данные которые хотим узнать к выбранному типу.строка 74(находим поле куда ввел данные пользователь)
3.Нажимаем на кнопку(фильтровать),находим ее в разметке на строке 67.
4.На кнопке (фильтровать) вешаем обработчик события по клику ,строка 70
5.Если пользователь оставил поля ввода пустым,то сработает условие на строке 77(внутри обработчика события)
6.Условие выведт пользователю предупреждение что строка не должна быть пустым 
 и вызовет функцию showNoResults(); на строке  80.
 7.Данная функция описана на строке 35.
 8.Она в свою  очередь вызовет функцию showNoResults = () => showResponseBlock('.dialog__response-block_no-results'),
 передав аргументом класс блока(сообщения для пользователя) котоый мы хотим показать пользователю.
 9.Функция showResponseBlock описана на строке 15. 
 Она вызываеют функцию hideAllResponseBlocks(описана на 8строчке),
 данная функция скрывает все блоки (сообщений для пользователя),у нас их 3 в разметке с классом div.dialog__response-block
10.Затем Селектор переданный аргументом для функции становиться видимым.
11.Далее следует условие 	if (spanSelector) строка 24. о нем ниже.



12.Вернемся к пункту 4.Если пользователь ввел информаци,то на строке 81,сработает else.
13.В данном блоке мы отменяем валидацию. И отменям стандартное поведение (отправка формы на сервер).
14.на строке 89 вызываем фунцию tryFilterByType.
15.В блоке try на строке 44,мы проверяем данные которые пользователь нам ввел.
16.В блоке try фильтруем данные вызвав функцию filterByType посредством функции eval,и записываем строчку в переменную 
17.записываем данные которые вернуло тернанрное условие в переменную(alertMsg)
18.затем выводим результат пользователю showResults(alertMsg).
19.в случае ошибки сработает блок catch(строка 63).
20.Она вызывает showError(описанную на строке 29);




В итоге. Если полюзователь не ввел ничего,он получит предупреждение что надо ввести данные.
Если пользователь ,введет не правильный формат,то выйдет ошибка.
Если формат соблюден правильно ,он получит сообщение а том какие именно данные соотвествуют выбранному типу.


*/
